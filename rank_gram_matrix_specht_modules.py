#compute dim D^{\lambda}
#define action of S_n on Young tableaux - DONE
#for a p-regular partition \lambda
#find basis elements e_i for Specht modules S^\lambda
#write basis e_T in terms of Young tableaux as in Chan's notes
#compute rank of Gram matrix (<e_i,e_j>)_{i,j=1,...,n} as in Chan's notes
#REF: Chan's notes - https://math.mit.edu/~charchan/ModularRepresentationsSymmetricGroupSeminar.pdf

#define action of S_n on Young tableaux T
def act(sigma,T):
    return Tableau([[sigma(l[i]) for i in range(len(l))] for l in T])

#define action on rows of tablueax
#g is an element of the subgroup \prod_i S_{n_i} where \sum_i n_i = n
#T is a tableau corresponding to some partition T.shape()
def act_rows(g,T):
    return [g[i](T[i]) for i in range(len(T))]

#determine when two tableaux are row-equivalent
def row_equiv(T_0,T_1):
    assert T_0.shape() == T_1.shape()
    return all(set(T_0[i])==set(T_1[i]) for i in range(len(T_0)))

#get columns of tableau
#there is a MUCH smarter way to do this
def cols(T):
    cols=[]
    for j in range(max(T.shape())):
        col=[]
        for i in range(len(T)):
            try:
                col.append(T[i][j])
            except:
                IndexError
        cols.append(col)
    return cols

#compute the column stabilizer of a tableau T
def col_stab(T):
    n=sum(T.shape())
    col_1 = cols(T)
    col_stabilizer = []
    for g in SymmetricGroup(n):
        col_2 = cols(act(g,T))
        assert len(col_1) == len(col_2)
        cols_preserved = True
        for i in range(len(col_1)):
            if set(col_1[i]) != set(col_2[i]):
                cols_preserved = False
        if cols_preserved:
            col_stabilizer.append(g)
    return col_stabilizer

#compute polytabloid e_T associated to a standard young tableau T
#e_T = \sum_{\sigma \in C_T} sgn(\sigma) { \sigma T}
#where {} is the row-equivalence class, i.e. a tabloid
#C_T is the column stabilizer, the subgroup of the symmetric group preserving the columns of tableau T setwise
#sgn is the sign of the permutation \sigma
#the sum takes place in the module generated by tabloids {T}
#represent lienar combination of tabloids as a dict={Tableau:Integer}
#if T_1 is equivalent to T_2, just increase the sum by sgn(\sigma)
#if T_1 is not equivalent to T_2, create a new entry
def polytabloid(T):
    e_T = {}
    C_T = col_stab(T)
    for pi in C_T:
        T_1 = act(pi,T)
        sum_contains_equiv = False
        for T_2 in e_T:
            if row_equiv(T_1,T_2):
                sum_contains_equiv = True
                e_T[T_2] += sgn(pi)
        if not sum_contains_equiv:
            e_T[T_1] = sgn(pi)
    return e_T

#compute bilinear form <.,.> associated to span of tabloids
#<{s},{t}> = \delta_{{s},{t}}
#takes in two dicts representing polytabloids e_{T_1} and e_{T_2}
#iterates through both keys only increasing the sum by the product of entries when {s}=={t}, i.e. s ~ t
def bilinear_form(poly_1,poly_2):
    sum = 0
    for s in poly_1:
        for t in poly_2:
            if row_equiv(s,t):
                sum += poly_1[s]*poly_2[t]
    return sum

#create a standard "canonical" tableau by placing entries sequentially from left-to-right, top-to-bottom
def canonical_tableau(la):
    return Tableau([[sum(la[k] for k in range(j))+i+1 for i in range(la[j])] for j in range(len(la))])

#use the bilinear form to compute the rank of the Gram matrix (<e_i,e_j>)_{i,j=1,...,n}
#note that polytabloids e_T form a basis for S^\lambda for *standard* tableau T
def gram_matrix(la):
    return [[bilinear_form(polytabloid(T_1),polytabloid(T_2)) for T_1 in StandardTableaux(la)] for T_2 in StandardTableaux(la)]

#compute the rank of the Gram matrix in characteristic 0
import numpy as np
la = Partitions(5)[4]
A=gram_matrix(la)
np.linalg.matrix_rank(A)

#A modulo 3
np.mod(A,3)

#compue the rank of the Gram matrix modulo 3
np.linalg.matrix_rank(np.mod(A,3),3)